# 定义接口属性
** ts的接口并不能像在其它语言里一样,说实现了某个接口,仅仅关新值的外形,所以可以直接把接口作为形参,起到类型约束作用.以下要求:**
通常 要求传递所有属性且类型相同,不限制传递属性的顺序
---
传递多余的值通常是没有意义的,如果传递的属性赋值了字面量,还会报错;
如果要传递接口中没有定义的属性:
1.传递时使用 as type 可以绕过检查:type为接受对象的类型
2.先将对象赋值给一个变量,然后传递这个变量,这样就不会检查多余的属性: 可能是因为let弱类型的原因!
ps: 以上2种做法虽然能绕过编译器检查,但是多余的属性可能毫无意义,因为接口没有定义这个属性,所以根本不会接受这些多余的属性
3.定义一个接受任意类型的属性,而且不关心他们的类型: [key: string]: any


可选修饰符? ,就是在定义变量时在变量名后跟一个? ,一般应该用于对可能纯在的属性预定义,也就是可以被忽略的属性:
name?: type

不可空类型,传入的值不能为空的:
name!: type


只读修饰符readonly ,进行一次赋值后就不可修改了;
readonly name: type
-->
typescript通常声明变量时使用const, 接口或类的属性使用 readonly
与其他语言机制可能有根本的区别,const变量在声明时就必须赋值,编译后就是字面量,存在于内存的静态常量区,
而readonly ,只是在代码编辑时约束,编译后就是普通变量,通常在棧中.

## Dictionary模式
可以使用string 和 number两种类型的键(key),但是键类型为number 的value 类型必须和键类型string 的value 类型相同或者为他的子类型,原因如下:
Dictionary本意是为了让两种键都会指向同一个对象,所以在调用时number 键会被转换为string
JavaScript中用['属性名']这样的方式访问一个属性, 语义检查会把已定义的属性名当做Dictionary的键,匹配他的返回类型;
一般情况使用number键可以避免属性名冲突,除非已经定义了一个纯数字的属性名,大多数人估计也不会这样做,这样也有个副作用,就是不易于阅读
如果还是没能完全匹配已定义属性,解决方案是使用元组



# 定义接口函数
## 定义
接口函数只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字,虽然没什么用,编译器只进行对应的参数类型检查。
接口中可以定没有名字的方法,使用这样的方法就是把接口对象名字,当做方法名一样使用.
有类似委托的效果:
export interface Func<T, Ts> {
    (a: T, b:Ts): boolean;
}
let fun : Func<T>;
fun=( a, b) => (a < b)

## 实现
函数的参数名不需要与接口里定义的名字相匹配,函数的参数会逐个进行类型检查，要求对应位置上的参数类型是兼容的(也就是类型相同或者能自动转换);


# 类类型
就是把属性类型设置为某个class类型

接口中使用new(形参)表示构造函数
construct属于class的静态部分,所以不能实现一个接口的构造函数,但是可以使用这个new对类的构造函数进行匹配

## 接口可以继承多个其他接口
