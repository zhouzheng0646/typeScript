# 定义接口属性
** ts的接口并不能像在其它语言里一样,说实现了某个接口,仅仅关新值的外形,所以可以直接把接口作为形参,起到类型约束作用.以下要求:**
通常 要求传递所有属性且类型相同,不限制传递属性的顺序,就像是定义了一组obj对象
[key]:[type]
---
传递多余的值通常是没有意义的,如果传递的属性赋值了字面量,还会报错;
如果要传递接口中没有定义的属性:
1.传递时使用 as type 可以绕过检查:type为接受对象的类型
2.先将对象赋值给一个变量,然后传递这个变量,这样就不会检查多余的属性: 可能是因为let弱类型的原因!
ps: 以上2种做法虽然能绕过编译器检查,但是多余的属性可能毫无意义,因为接口没有定义这个属性,所以根本不会接受这些多余的属性
3.定义一个接受任意数量的属性,而且不关心他们的类型: [key: string]: any, 其实就是一个类似字典的玩意,使用key只能是string或者number, value使用只能是any


可选修饰符? ,就是在定义变量时在变量名后跟一个? ,一般应该用于对可能纯在的属性预定义,也就是可以被忽略的属性:
name?: type


只读修饰符readonly ,进行一次赋值后就不可修改了;
readonly name: type
-->
typescript通常声明变量时使用const, 接口或类的属性使用 readonly
其他语言中可能有根本的区别,const变量在声明时就必须赋值,编译后就是字面量,存在于内存的静态常量区,
而readonly ,只是在代码编辑时约束,编译后就是普通变量,通常在棧中.



# 定义接口函数
## 定义
接口函数只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字,虽然没什么,编译器只进行对应的参数类型检查。
当接口只有一个函数的时候,可以直接吧这个函数的实现传给这个接口,因为对接口赋值就是实现这个接口:

export interface Func<T> {
    (a: T, b: T, ...c: T[]): boolean;
}
let fun : Func<T>;
fun=( a, b, c, d, e, ...) => (a < b && b < c && c < d)

## 实现

函数的参数名不需要与接口里定义的名字相匹配,函数的参数会逐个进行类型检查，要求对应位置上的参数类型是兼容的(也就是类型相同或者能自动转换);
传递实参也可以不写类型,类型检查器会根据,对函数传递的值进行推断类型,但是不推荐,这样的代码阅读性可能没那么好


