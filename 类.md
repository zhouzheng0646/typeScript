** TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。**
** 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private或 protected成员，
那么只有当另外一个类型中也存在这样一个成员，我们才认为这两个类型是兼容的。也就是说只有这个 类本身的实例对象 和 派生类对象 能够兼容**
---也许是因为没有指针这样的东西,所以无法实现真正意义上的类,只是最大外形上的模拟,所以类型匹配上只能是,对每个属性进行匹配验证,所以可以被匿名类型直接赋值

typescript中如果使用了一个没有初始化的对象(没有new的类),似乎不会有警告或者编译错误提示


## 构造函数constructor
参数属性:
作用呢就是直接构造函数的 形参列表 进行属性声明. 
简化了声明后还要在构造体内进行赋值初始化的操作.如果要重载构造函数或许并不实用

存取器:
就是使用 get set来访问属性,属性本身设为private,
如果只带有 get,不带有 set的存取器自动被推断为 readonly

静态属性:
使用static修饰, 使用 类名.属性名 访问,他的访问层级和这个类是相同的,也不需要构造时初始化

## 继承
派生类必须先调用super才能开始使用this,用于初始化从基类继承过来的属性


## 抽象类
抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。
abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法, 抽象方法必须被子类实现.
不允许创建一个抽象类的实例,但是可以创建一个子类的实例赋值给抽象类的对象,这样的对象只能使用抽象类锁包含的成员

